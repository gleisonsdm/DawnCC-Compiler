//===-------------------------- recoverCode.cpp ---------------------------===//
//
//                     The LLVM Compiler Infrastructure
//
// This file is distributed under the Universidade Federal de Minas Gerais -
// UFMG Open Source License. See LICENSE.TXT for details.
//
// Copyright (C) 2015   Gleison Souza Diniz Mendon?a
//
//===----------------------------------------------------------------------===//
//
// RecoverCode is a class created for generate C code using  PtrRangeAnalysis
// to define the data limits used to access a pointer in some loop.
// In summary, this class translate the access expressions in LLVM's I.R. and
// use the original name of variables to write the correct parallel code.
//
// The name of variables generated by pass stay in NAME string. The 
// programmer can change this name in writeExpressions.h
//
// This class is used in the WriteExpressions optimization, and its just rewrite
// the instructions in LLVM's IR to C code. Its will optimize the code available, 
// using for example:
//
//    -> propagation of the constants
//    -> reuse of the generated code
//    -> removing of the redundant instructions
//    -> removing of the dead code
//    -> simplifications of the constans
//    -> simplifications of the generated code
//
//===----------------------------------------------------------------------===//

#include <fstream>
#include <queue>

#include "llvm/IR/DIBuilder.h" 
#include "llvm/IR/Module.h"
#include "llvm/Support/CommandLine.h"
#include "llvm/Support/DataTypes.h"
#include "llvm/Support/Debug.h"
#include "llvm/Support/raw_ostream.h"
#include "llvm/Analysis/ValueTracking.h"
#include "llvm/IR/DerivedTypes.h"
#include "llvm/MC/MCExpr.h"
#include <llvm/Transforms/Utils/BasicBlockUtils.h>

#include "recoverCode.h" 
#include "PtrRangeAnalysis.h"
#include "restrictifier.h"

#define ACC '0'
#define OMP_GPU '1' 
#define OMP_CPU '2'

using namespace llvm;
using namespace std;
using namespace lge;

void RecoverCode::setOMP (char omp) {
  OMPF = omp;
}

char RecoverCode::OMPType() {
  return OMPF;
}

void RecoverCode::clearCommands() {
  this->NewVars = 0;
  commands.erase(commands.begin(), commands.end());
}

void RecoverCode::insertComputedValue (Value *V, int *id, std::string str) {
  if (ComputedValues.count(V) != 0)
    return;
  ComputedValues[V] = std::make_pair(*id, str); 
}

bool RecoverCode::selectComputedValue (Value *V, int *id, std::string *str) {
  if (ComputedValues.count(V) == 0)
    return false;
  *id = ComputedValues[V].first;
  *str = ComputedValues[V].second;
  return true;
}

void RecoverCode::setPointerNull() {
  this->PointerValue = nullptr;
}
void RecoverCode::setPointer (Value *V) {
  this->PointerValue = V;
}

Value *RecoverCode::getPointer () {
  return this->PointerValue;
}

void RecoverCode::setNAME (std::string name) {
  this->NAME = name;
}

void RecoverCode::setValidTrue () {
  this->Valid = true;
}

void RecoverCode::setValidFalse () {
  this->Valid = false;
}

bool RecoverCode::isValid () {
  return this->Valid;
}

// Return the new index to use in Analysis.
int RecoverCode::getNewIndex () {
  return NewVars++;
}

// Clear the expression for other uses. 
void RecoverCode::clearExpression () {
  Expression.erase(Expression.begin(),Expression.end());
}

int RecoverCode::getIndex () {
  return this->NewVars;
}

// Return a unique string to insert in the source file.
std::string RecoverCode::getUniqueString () {
  std::string result = std::string();
  std::vector <std::string> Exp(getIndex());
  std::string value = std::string();
  
  for (std::map<std::string, int>::iterator I = this->commands.begin(),
       IE = this->commands.end(); I != IE; I++) {
    Exp[I->second] = I->first;
  }
  
  for (unsigned int i = 0, ie = (Exp.size()-1); i < ie; i++) {
    result +=  NAME + "[" + std::to_string(i) + "] = ";
    result += Exp[i];
  }
  
  return result;
}

// This method insert or re-use some expression available:
void RecoverCode::insertCommand (int* var, std::string expression) {
  if (this->commands.count(expression) > 0) {
    *var = this->commands[expression];
    return;
  }
  
  *var = getNewIndex();
  this->commands[expression] = *var; 
}

std::string RecoverCode::selectCommand (int var) {
  if (var == -1)
    return std::string();
  
  for (std::map<std::string, int>::iterator I = this->commands.begin(),
       IE = this->commands.end(); I != IE; I++)
    if (I->second == var)
       return I->first;

   return std::string();
}

// Return the correct string to PtrToInt Instruction
std::string RecoverCode::getPtrToIntExp (PtrToIntInst *I,
                                       std::string name, int *var,
                                       const DataLayout *DT) {
  std::string expression = std::string();
  int op1,op2;

  expression += getAccessString(&(*I->getOperand(0)), name, &op1, DT);
  
  if (op1 == -1)
    return expression;

  expression += "(long long int) " + NAME + "[" + std::to_string(op1) + "]"; 
  expression += ";\n";
  insertCommand(var, expression);
  return std::string();
}

// Return the correct string to IntToPtr Instruction
std::string RecoverCode::getIntToPtrExp (IntToPtrInst *I,
                                       std::string name, int *var,
                                       const DataLayout *DT) {
  std::string expression = std::string();
  int op1,op2;

  expression += getAccessString(&(*I->getOperand(0)), name, &op1, DT);
  
  if (op1 == -1)
    return expression;
 
  expression += "(long long int) " + NAME + "[" + std::to_string(op1) + "]";
   
  expression += ";\n";
  insertCommand(var, expression);
  return std::string();
}

/// Return the result of Analysis for SextExp Instruction:
std::string RecoverCode::getSextExp (SExtInst *I, std::string name,
                                          int *var, const DataLayout *DT) {
  return getAccessString(I->getOperand(0),name,var, DT);
}

std::string RecoverCode::getZextExp (ZExtInst *I, std::string name,  
                                              int *var, const DataLayout *DT) {                    
  return getAccessString(I->getOperand(0),name,var, DT);
} 

// Return the Expression to Generic Expression in LLVM.
// The available instruction in this void is:
//    -> Addition
//    -> Subtraction
//    -> Multiplication
//    -> Division
//
std::string RecoverCode::getGenericExp (Instruction *I,
                                                std::string name, int *var,
                                                const DataLayout *DT) {
  std::string signal = std::string(), expression = std::string();
  std::string value1 = std::string(), value2 = std::string();
  int op1 = -1, op2 = -1;
  long long int num1 = 0, num2 = 0, result = 0;
  long long int maskSum = 1, maskMul = 1;
  maskSum <<= 62;
  maskMul <<= 31;
  bool isInteger = false;
  if (!I || I->getNumOperands() != 2) {
     setValidFalse();
     return std::string();
  }

  value1 = getAccessString(&(*I->getOperand(0)),name, &op1, DT);
  value2 = getAccessString(&(*I->getOperand(1)),name, &op2, DT);

  if ((op1 == -1 && op2 == -1) && (TryConvertToInteger(value1, &num1)
      && TryConvertToInteger(value2, &num2)))
    isInteger = true;
  
  switch (I->getOpcode()) {
    case Instruction::Add:
      signal = "+";
      if (isInteger && ((num1 > maskSum) || (num2 > maskSum)))
        setValidFalse();
      result = num1 + num2;
    break;
    case Instruction::Sub:
      signal = "-";
      if (isInteger && ((num1 > maskSum) || (num2 > maskSum)))
        setValidFalse();
      result = num1 - num2;
    break;
    case Instruction::Mul:
      signal = "*";
      if (isInteger && ((num1 > maskMul) || (num2 > maskMul))) 
        setValidFalse();
      result = num1 * num2;
    break;
    case Instruction::UDiv:
      signal = "/";
      if (num2 != 0)
        result = num1 / num2;
    break;
    case Instruction::SDiv:
      signal = "/";
      if (num2 != 0)
        result = num1 / num2;
    break;
    case Instruction::LShr :
      signal = ">>";
      result = num1 >> num2;
    break;
    case Instruction::Shl :
      signal = "<<";
      result = num1 << num2;
    break;
    case Instruction::And :
      signal = "&";
      result = num1 & num2;
    break;
    case Instruction::Or :
      signal = "|";
      result = num1 | num2;
    break;
    case Instruction::Xor :
      signal = "^";
      result = num1 ^ num2;
    break;
    case Instruction::AShr :
      signal = ">>";
      result = num1 >> num2;
    break;
    case Instruction::SRem :
      signal = "%";
      if (num2 != 0)
        result = num1 % num2;
    break;
  }
  
  if (signal == std::string()) {
    setValidFalse();
    return std::string();
  }

  if (value1 == "0" && signal == "+") {
    *var = op2;
    return value2;
  }

  if (value2 == "0" && signal == "+") {
    *var = op1;
    return value1;
  }

  if (value1 == "1" && (signal == "*")) {   
    *var = op2;
    return value2;
  }

  if (value2 == "1" && (signal == "*" || signal == "/")) {
    *var = op1;
    return value1;
  }

  if (isInteger)
    return std::to_string(result);

  expression += value1;
  if (op1 != -1)
     expression += NAME + "[" + std::to_string(op1) + "]";

  expression += " " + signal + " ";
  
  expression += value2;
  if (op2 != -1)
    expression += NAME + "[" + std::to_string(op2) + "]";

  expression += ";\n"; 
  
  insertCommand(var, expression);
  return std::string();
}

bool RecoverCode::isMallocCall (const CallInst *CI) {
  if (!CI)
    return false;

  const Module* M = CI->getParent()->getParent()->getParent();
  Function *MallocFunc = M->getFunction("malloc");
  Function *CallocFunc = M->getFunction("calloc");
  Function *ReallocFunc = M->getFunction("realloc");

  if (CI->getCalledFunction() != MallocFunc && 
      CI->getCalledFunction() != CallocFunc &&
      CI->getCalledFunction() != ReallocFunc)
    return false;

  return true;
}

// This void return the Name of some Variable for some memory access
// instruction:
std::string RecoverCode::getNameExp (Value *V, std::string name, int *var,
                                              const DataLayout *DT) {
  if (((!isa<LoadInst>(V) && !isa<StoreInst>(V)) 
        && (!isa<AllocaInst>(V) && !isa<GlobalVariable>(V)))
        && ((!isa<GetElementPtrInst>(V) && !isa<Argument>(V))
        && !isa<CallInst>(V)) && !isa<PHINode>(V))
    return std::string();

  *var = -1;
  RecoverNames::VarNames nameF = rn->getNameofValue(V);

  if (!isa<GetElementPtrInst>(V)) {
    if (name == nameF.nameInFile)
      return "0";
   
    if (nameF.nameInFile == std::string()) {
      setValidFalse();     
      return std::string();
    }
    
    return nameF.nameInFile;
  }

  GetElementPtrInst *GEP = cast<GetElementPtrInst>(V);
  Value *value = GEP; 
  std::string expression = std::string();
  std::vector<std::pair<int,string> > indexes;

  long long int index = 0, tmpIndex = 0;
  int op = -1;
  bool isIntegerIndex = true;
  std::string sIndex = std::string();
  if (nameF.nameInFile == std::string()) {
    while (nameF.nameInFile == std::string()) {
      nameF = rn->getNameofValue(value);
      // Try to find the base pointer if value is a load or store
      if (LoadInst *LD = dyn_cast<LoadInst>(value))
        break;
      if (StoreInst *SI = dyn_cast<StoreInst>(value))
        break;
      // Finish the Analysis to other instructions in IR
      if (!isa<GetElementPtrInst>(value))
        break;
      
      GEP = cast<GetElementPtrInst>(value);
      sIndex = getIndextoGEP(GEP, name, &op ,DT);
      
      if (TryConvertToInteger(sIndex, &tmpIndex))
        index += tmpIndex;
      else {
        isIntegerIndex = false;
        indexes.push_back(std::make_pair(op,sIndex));
        // Implements to work with complex getElementPointer context.
        // This part of code need rewrite values like this:
        //    %v1 = getElementPointer( %v, ...)
        //    %v2 = getElementPointer( %v1, ...)
      }
      /*if (isa<GetElementPtrInst>(GEP->getPointerOperand()) &&
          ((TryConvertToInteger(sIndex, &tmpIndex) && tmpIndex != 0) ||
           op != -1)) {
        GEP->getPointerOperand()->dump();
        errs() << sIndex << "\n";
        errs() << "tmpIndex = " << tmpIndex << "\n";
;
         setValidFalse();
      }*/
      value = GEP->getOperand(0);
    }
  }
  else { 
    sIndex = getIndextoGEP(GEP, name, var, DT);
   
    if (TryConvertToInteger(sIndex, &tmpIndex))
      index = tmpIndex;
    else 
      isIntegerIndex = false;
    indexes.push_back(std::make_pair(*var,sIndex));
  }
 
  if (name != nameF.nameInFile)
    expression += nameF.nameInFile + "[";
  
  if (isIntegerIndex)
    expression += std::to_string(index);
  else {
    index = 0;
    bool justInteger = true;
    std::string exp = std::string();
    
    // Connects the indexes to read more complex expressions
    // As an example:
    //    %v1 = getElementPointer( %v, ...)
    //    %v2 = getElementPointer( %v1, ...)
    for (int i = 0, ie = indexes.size(); i != ie; i++) {
      if (TryConvertToInteger(indexes[i].second, &tmpIndex))
        index += tmpIndex;
      else
        justInteger = false;
    }
    
    if (!justInteger) {
      if (indexes.size() == 1)
        expression += indexes[0].second;
      else {
        std::string lastExp = std::to_string(index);
        for (int i = 0, ie = indexes.size(); i != ie; i++)
          if (!TryConvertToInteger(indexes[i].second,&tmpIndex)) {
            exp = lastExp + " + ";
            exp += indexes[i].second + ";\n";
            int op = -1;
            insertCommand(&op, exp);
            lastExp = NAME + "[" + std::to_string(op) + "]"; 
          }
        expression = lastExp;
      }
    }
    else  {
      expression = sIndex;
    }
  }

  if (name != nameF.nameInFile)
    expression += "]";

  if (nameF.nameInFile == std::string()) {
    setValidFalse();
    return std::string();
  }
  return expression;
}
//  The functions available below have two options of return.
//  If possible, return a std::string with the correspondent value, in the other
//  case, return a struct of strings. Look at the examples:
//  
//  First option:
//
//    LLVM[9] = LLVM[8] > LLVM[7];
//    LLVM[10] = LLVM[9] ? LLVM[3] : LLVM[6];
//  
//  Second option:
//
//    LLVM[9] = n > m;
//   LLVM[10] = LLVM[9] ? 532 : 412;
//
// This function retrun the the correct string to Select Instruction in LLVM IR:
std::string RecoverCode::getSelExp (SelectInst *SI, std::string ptrName,
                                      int *var, const DataLayout *DT) {
  int op1 = -1;
  std::string expression = std::string();
  bool result;
  
  if (ICmpInst *ICI = dyn_cast<ICmpInst>(&(*SI->getCondition())))
	  result = getCmpExp(ICI,ptrName, &op1, DT);
  
  if (op1 == -1) {
    if (result) 
      expression += getAccessString(&(*SI->getTrueValue()),ptrName, &op1, DT);
    else
      expression += getAccessString(&(*SI->getFalseValue()),ptrName, &op1, DT);
   
    *var = op1; 
    return expression;  
  }

  int op2 = -1, op3 = -1;
  expression += "(" + NAME + "[" + std::to_string(op1) + "] ? ";
  
  expression += getAccessString(&(*SI->getTrueValue()),ptrName, &op2, DT);
  if (op2 != -1)
    expression += NAME + "[" + std::to_string(op2) + "]";

  expression += " : ";
  
  expression += getAccessString(&(*SI->getFalseValue()),ptrName, &op3, DT);
  
  if (op3 != -1)
    expression += NAME + "[" + std::to_string(op3) + "]";

  expression += ");\n";
  insertCommand(var, expression);
  return std::string();
}

bool RecoverCode::TryConvertToInteger(std::string value, long long int* result) {
  *result = 0;
  int i = 0, ie = value.size(), signal = 1;
  if (ie > 0 && value[0] == '-') {
    i++;
    signal = -1;
  }
  while(i < ie) {
    if (value[i] < '0' || value[i] > '9') {
      *result = 0;
      return false;
    }
    *result *= 10;
    *result += value[i] - '0';
    i++;
  }
  *result = (*result * signal);
  return true;
}

// "getCmpExp" return a correct compare instruction in string format.
// Try solve and simplify some expressions while the two operands are
// defined. Please, take a look below:
//
// (5 < 5)
// 
// This result is always false.
bool RecoverCode::getCmpExp (ICmpInst *ICI, std::string ptrName,
                                  int *var, const DataLayout *DT) {
  std::string expression = std::string(), value1 = std::string();
  std::string value2 = std::string(), signal = std::string();
  int op1 = -1, op2 = -1;
  long long int num1 = 0, num2 = 0;
  bool isEqual = false, cmpResult = false, isIntegers = false;

  value1 = getAccessString(&(*ICI->getOperand(0)),ptrName, &op1, DT);
  value2 = getAccessString(&(*ICI->getOperand(1)),ptrName, &op2, DT);

  if (((op1 == op2) && op1 != -1 ) || 
      ((value1 == value2) && (op1 == -1 && op2 == -1)))
    isEqual = true;

  if ((TryConvertToInteger(value1, &num1) && TryConvertToInteger(value2, &num2))
       && (op1 == -1 && op2 == -1))
    isIntegers = true;
  
  if (isEqual) {
    num1 = 0;
    num2 = 0;
  }

  if (ICI->isIntPredicate())
    switch (ICI->getPredicate()) {
      case ICmpInst::ICMP_EQ:
        signal = "==";
        cmpResult = (num1 == num2);
      break;
      case ICmpInst::ICMP_NE:
        signal = "!=";
        cmpResult = (num1 != num2);
      break;
      case ICmpInst::ICMP_UGT:
        signal = ">";
        cmpResult = (num1 > num2);
      break;
      case ICmpInst::ICMP_UGE:
        signal = ">=";
        cmpResult = (num1 >= num2);
      break;
      case ICmpInst::ICMP_ULT:
        signal = "<";
        cmpResult = (num1 < num2);
      break;	
      case ICmpInst::ICMP_ULE:
        signal = "<=";
        cmpResult = (num1 <= num2);
      break;
      case ICmpInst::ICMP_SGT:
        signal = ">";
        cmpResult = (num1 > num2);
      break;
      case ICmpInst::ICMP_SGE:
        signal = ">=";
        cmpResult = (num1 >= num2);
      break;
      case ICmpInst::ICMP_SLT :
        signal = "<";
        cmpResult = (num1 < num2);
      break;
      case ICmpInst::ICMP_SLE:
        signal = "<=";
        cmpResult = (num1 <= num2);
      break;
  }

  if (isIntegers || isEqual)
    return cmpResult;

  expression += value1;
  if (op1 != -1)
    expression += NAME + "[" + std::to_string(op1) + "]";
  expression += " ";

  expression += signal;

  expression += " " + value2;
  if (op2 != -1)
    expression += NAME + "[" + std::to_string(op2) + "]";

  expression += ";\n";
  insertCommand(var, expression);
  return false;
}

// Try solve a PHINode, if it has a name, return its name.
std::string RecoverCode::getPHINode (Value *V, std::string ptrName, int *var,
                                     const DataLayout *DT) {
  if (!isa<PHINode>(V))
    return std::string();

  // Try find in all operands of PHINode the name, if the name are the same,
  // return this name. Return a empty string in the other case.
  PHINode *PHI = cast<PHINode>(V);
  std::map<std::string, bool> names;
  for (int i = 0, ie = PHI->getNumIncomingValues(); i != ie; i++) {
    std::string expression = std::string();
    expression = getNameExp(PHI->getIncomingValue(i), ptrName, var, DT);
    if (expression == std::string()) {
      RecoverNames::VarNames nameF = rn->getNameofValue(PHI->getIncomingValue(i));
      expression = nameF.nameInFile;
    }
    if (expression != std::string())
      names[expression] = true;
  }

  if (names.size() == 1)
    return names.begin()->first;

  errs() << "\n" << names.size() << " names for:\n";
  for (auto I = names.begin(), IE = names.end(); I != IE; I++) {
    errs() << I->first << "\n";
  } 
  return std::string();
}

// This method decide how the value V will be treated.
std::string RecoverCode::getAccessString (Value *V, std::string ptrName,
                                                  int *var,
                                                  const DataLayout *DT) {
  if (!isValid()) {
    return std::string();
  }
  // Default Value is "-1", to identify empty values in pass.
  *var = -1;
  std::string name = std::string();
  
  // Return the compute value, if exists.
  if (selectComputedValue(V, var, &name))
    return name;
  
  // Return to PHINode it's name, if is knowed.
  name = getPHINode(V, ptrName, var, DT);
  if (name != std::string()) {
    insertComputedValue(V, var, name);
    return name;
  }

  //To memory access instruction, return the name.
  name = getNameExp(V, ptrName, var, DT);
  if (name != std::string()) {
    insertComputedValue(V, var, name);
    return name;
  }

  if (Constant *C = dyn_cast<Constant>(V)) {
    ConstantsSimplify CS;
    long long int value = CS.getUniqueConstantInteger(C, getPointer() ,DT);
    if (CS.isValid()) {
      insertComputedValue(V, var, std::to_string(value));
      return std::to_string(value);
    }
    setValidFalse();
    return "0";
  }

  // Return a empty string if the value isn't a Instruction.
  if (!isa<Instruction>(V) || isa<PHINode>(V)) {
    setValidFalse();
    return std::string();
  }

  if (CallInst* CI = dyn_cast<CallInst>(V)) {
    if (!isMallocCall(CI)) {
      setValidFalse();
      return std::string();
    }
    RecoverNames::VarNames nameF = rn->getNameofValue(V);
    if (nameF.nameInFile == std::string())
      setValidFalse();
    if (nameF.nameInFile != ptrName) {
      insertComputedValue(V, var, nameF.nameInFile);
      return nameF.nameInFile;
    }
    insertComputedValue(V, var, "0");
    return "0";
  } 

  Instruction *I = cast<Instruction>(V);
  if (!I || isa<ICmpInst>(I))
    return std::string(); 

  if (ZExtInst *ZInst = dyn_cast<ZExtInst>(I)) {
    std::string result = getZextExp(ZInst, ptrName, var, DT);
    insertComputedValue(V, var, result);
    return result;
  }

  if (SExtInst *SInst = dyn_cast<SExtInst>(I)) {
    std::string result = getSextExp(SInst, ptrName, var, DT);
    insertComputedValue(V, var, result);
    return result;
  }

  if (BitCastInst *BIT = dyn_cast<BitCastInst>(V)) {
    std::string result =  getAccessString(BIT->getOperand(0), ptrName, var,DT);
    insertComputedValue(V, var, result);
    return result;
  }

  if (SelectInst *SI = dyn_cast<SelectInst>(I)) {
    std::string result =  getSelExp(SI, ptrName, var, DT);
    insertComputedValue(V, var, result);
    return result;
  }

  if (PtrToIntInst *PtrInst = dyn_cast<PtrToIntInst>(I)) {
    std::string result =  getPtrToIntExp(PtrInst, ptrName, var, DT);
    insertComputedValue(V, var, result);
    return result;
  }

  if (IntToPtrInst *PtrInst = dyn_cast<IntToPtrInst>(I)) {
    std::string result =  getIntToPtrExp(PtrInst, ptrName, var, DT);
    insertComputedValue(V, var, result);
    return result;
  }



  std::string result = getGenericExp(I, ptrName,var, DT);
  insertComputedValue(V, var, result);
  return result;
}

Region* RecoverCode::regionofBasicBlock (BasicBlock *bb,
                                                  RegionInfoPass *rp) {
  Region *r = rp->getRegionInfo().getRegionFor(bb);
  return r;
}

void RecoverCode::initializeNewVars () {
  setValidTrue();
  clearExpression();
  ComputedValues.erase(ComputedValues.begin(), ComputedValues.end());
  this->NewVars = 0;
}

unsigned int RecoverCode::getSizeInBytes (unsigned int sizeInBits)
                                                   const {
  return ((sizeInBits + 7) / 8);
}

void RecoverCode::setRecoverNames (RecoverNames *RN) {
  this->rn = RN;
}

// Return the memory size used for this type, but consider the number of this
// types used. For example:
//   sizeof(int) * 5
//     => 20
//   sizeof(long long int) * 8
//     => 64
long long int RecoverCode::getSumofTypeSize (Type* TPY, int position,
                                                     const DataLayout* DT) {
  long long int value = 0;
  ConstantsSimplify CS;
  Type* tpy = getInternalType(TPY,position,DT);
  // Use Data Layout, returns the position X the size in bytes of variable.
  if (TPY->getTypeID() != Type::StructTyID) {
    value = CS.getSizeToType(tpy,DT);
    value = value * position;
    return value;
  }
  // Return the Size of struct until the informed position.
  Type* Tpy;
  if (position > TPY->getNumContainedTypes()) {
     setValidFalse();
     return 0;
  }
  for (unsigned int i = 0, ie = position; i < ie; ++i) {
    Tpy = TPY->getStructElementType(i);
    value += CS.getSizeToType(Tpy,DT);
  }
  return value;
}

// Generate a index to GEP Instruction, this method will calculate the index to
// referenced array of this GEP.
std::string RecoverCode::getIndextoGEP (GetElementPtrInst*  GEP,
                                std::string name,
                                int* var, const DataLayout* DT) { 
  ConstantsSimplify CS;
  long long int value = 0, sum = 0;
  std::string exp = std::string();
  // Vector with the all instructions that we need to generate the gep
  std::vector <std::pair <std::string, int> > indexList;
  Type* tpy = GEP->getPointerOperandType(); 
  for (GetElementPtrInst::op_iterator I = GEP->idx_begin(), IE = GEP->idx_end();
       I != IE; ++I) {
    if (Constant *C = dyn_cast<Constant>(I)) {
      value = CS.getUniqueConstantInteger(C, getPointer() ,DT);
      value = getSumofTypeSize(tpy,value,DT);
      sum += value;
      if (!CS.isValid()) {
        setValidFalse();
      }
    }
    else {
     int op = -1;
     long long int num = 0;
     exp = getAccessString(*I, name, &op, DT);

     // Provide the correct BasePointer:
     Instruction *Inst = nullptr;
     if (isa<Instruction>(I))
       Inst = cast<Instruction>(I);
     Value *vl = Inst;

     while (vl) {
       if (isa<Argument>(Inst))
         break;
       if (isa<AllocaInst>(Inst))
         break;
       if (isa<GlobalValue>(Inst))
         break;
       if (isa<PHINode>(Inst))
         break;
       vl = Inst->getOperand(0);
       if (!isa<Instruction>(vl))
         break;
       Inst = cast<Instruction>(vl);
     }
     if (vl) {
      Type *tp = nullptr;
      if (Argument *Arg = dyn_cast<Argument>(vl))
        tp = Arg->getType();
      else if (AllocaInst *Alc = dyn_cast<AllocaInst>(vl))
        tp = Alc->getType();
      else if (GlobalValue *Gvl = dyn_cast<GlobalValue>(vl))
        tp = Gvl->getType();
      else if (BitCastInst *Bi = dyn_cast<BitCastInst>(vl))
        tp = Bi->getType();
      if (tp) {
        Type *tpe = getInternalType(tp, 0, DT);
        if (tpe != tp)
          if (isValidPointer(vl,DT)) {
            exp = "*" + exp;
          }
      }        
    }

      if (TryConvertToInteger(exp, &num) && op == -1) {
        sum += getSumofTypeSize(tpy, num, DT);
      }
      else {
        std::string exp2 = std::string();
        if (op != -1)
          exp2 = (NAME + "[" + std::to_string(op) + "]");
        else
          exp2 = exp;
        exp2 += " * ";
        exp2 += std::to_string(getSumofTypeSize(tpy, 1, DT));
        exp2 += ";\n";
        insertCommand(&op, exp2);
        indexList.push_back(std::make_pair(exp2,op));
      }    
    }
    tpy = getInternalType(tpy,value,DT);
  }
  if (!indexList.empty()) {
    if (sum != 0)
      indexList.push_back(std::make_pair(std::to_string(sum),sum));
  } else {
    *var = -1;
    return std::to_string(sum);
  }
  int op = indexList[0].second;
  if (indexList[0].second != -1)                                               
    exp = (NAME + "[" + std::to_string(indexList[0].second) + "]");                  
  else                                                                         
    exp = indexList[0].first; 
  for (unsigned int i = 1, ie = indexList.size(); i < ie; i++) {
    exp += " + ";
    if (indexList[i].second != -1)
      exp += (NAME + "[" + std::to_string(indexList[i].second) + "]"); 
    else
      exp += indexList[i].first;
    exp += ";\n";
    insertCommand(&op, exp);
    exp = (NAME + "[" + std::to_string(op) + "]");
  }
  *var = -1;
  return exp;
}

// Return the subType to the type named "tpy", if possible.
// If not, return the same type of "tpy"
Type* RecoverCode::getInternalType (Type *tpy, int position,
                                                  const DataLayout *DT) { 
  if (tpy->getTypeID() == Type::ArrayTyID)
    return tpy->getArrayElementType();
  if (tpy->getTypeID() == Type::StructTyID) {
    if (tpy->getNumContainedTypes() <= position)
      return *tpy->subtype_begin();
    return tpy->getStructElementType(position);
  }
  if (tpy->getTypeID() == Type::PointerTyID)
    return tpy->getPointerElementType();
  return tpy;
}

// Return the size, in Bits, for value named "V"
unsigned int RecoverCode::getSizeToValue (Value *V,
                                                   const DataLayout *DT) {
  if (V)
    return getSizeToType(V->getType(),DT);

  setValidFalse();
  return 0; 
}

// Return the size, in Bits, to a Type. If the type is a Array or Pointer Type,
// return the size of the subType
unsigned int RecoverCode::getSizeToType (Type *tpy,
                                                  const DataLayout *DT) {
  switch (tpy->getTypeID()) {
    case Type::ArrayTyID : {
      return getSizeToType(tpy->getArrayElementType(),DT);
    }
    break;
    case Type::HalfTyID:
      return tpy->getPrimitiveSizeInBits();
    break;
    case Type::Type::FloatTyID:
      return tpy->getPrimitiveSizeInBits();
    break;
    case Type::DoubleTyID:                                                     
      return tpy->getPrimitiveSizeInBits();
    break;
    case Type::X86_FP80TyID: 
      return tpy->getPrimitiveSizeInBits();
    break;
    case Type::FP128TyID:
      return tpy->getPrimitiveSizeInBits();
    break;
    case Type::PPC_FP128TyID:                                                  
      return tpy->getPrimitiveSizeInBits();                            
    break;         
    case Type::X86_MMXTyID:                                                    
      return tpy->getPrimitiveSizeInBits();                            
    break;         
    case Type::IntegerTyID:                                                    
      return tpy->getPrimitiveSizeInBits();
    break;         
    case Type::VectorTyID:                                                     
      return tpy->getPrimitiveSizeInBits();                            
    break;
    case Type::StructTyID: { 
      StructType *ST = cast<StructType>(tpy);
      if (ST->isOpaque()) {
        setValidFalse();
        return 0;
      }
      const StructLayout *SL = DT->getStructLayout(ST);
      return SL->getSizeInBits();
    }
    break;
    case Type::PointerTyID: 
      return getSizeToType(tpy->getPointerElementType(),DT);
    break;
    default:
    // Not works to:                                                        
    //   -> Token
    //   -> Label
    //   -> Metadata
    //   -> Function
    break;
  }
  return 0;
}

// Insert a validation before the loop
// we need to write this as the last instruction before the use.
std::string RecoverCode::getValidBounds (std::string Expression, int *Index) {
  long long int num = -1;
  if (*Index == -1 && TryConvertToInteger(Expression, &num)) {
    if (num > 0)
      return Expression;
    return std::to_string(0);
  }
  // Here, we have a simbols that identify the bounds, we need to write
  // the computation
  Expression = "(" + NAME + "[" + std::to_string(*Index) + "] > 0);\n";
  int Index2 = -1;
  insertCommand(&Index2, Expression);
  
  Expression = "(" + NAME + "[" + std::to_string(Index2) + "] ? ";
  Expression += NAME + "[" + std::to_string(*Index) + "] : 0);\n";
  insertCommand(&Index2, Expression);
  
  return (NAME + "[" + std::to_string(Index2) + "]");
}

// return true if the pointer is valid to write the pragmas.
bool RecoverCode::isValidPointer (Value *Pointer, const DataLayout* DT) {
  Type *Ty = nullptr;
  if (!Pointer)
    return false;
  if (isa<GlobalValue>(Pointer) || isa<AllocaInst>(Pointer))
    Ty = getInternalType(Pointer->getType(), 0, DT);
  if (BitCastInst *BI = dyn_cast<BitCastInst>(Pointer))
    Ty = BI->getType();
  if (isa<Argument>(Pointer))
    Ty = Pointer->getType();
  if (AllocaInst *AI = dyn_cast<AllocaInst>(Pointer))
    Ty = AI->getAllocatedType();
  if (Ty == nullptr)
    return false;
  Ty = getInternalType(Ty, 0, DT);
  // After analyze all possible instructions, validate the type,
  if (Ty->getTypeID() == Type::ArrayTyID ||
      Ty->getTypeID() == Type::PointerTyID) {
    return false;
  }
  return true;
}

// Return a string with the access Expression to the pointer.
std::string RecoverCode::getAccessExpression (Value* Pointer, Value* Expression,
                                             const DataLayout* DT, bool upper) {
  int var = -1, number = 0;
  RecoverNames::VarNames nameF = rn->getNameofValue(Pointer);

  if (CallInst *CI = dyn_cast<CallInst>(Pointer))
    if (isMallocCall(CI))
    Pointer = rn->getPointerFnCall(CI);

  if (!Pointer || isa<CallInst>(Pointer)) {
    setValidFalse();
    return std::string();
  }

  // Provide 2 or more dimmentional arrays representation.
  if (isPointerMD(Pointer)) {
    if (!upper)
      return std::to_string(0);
    else
      return getPointerMD(Pointer, nameF.nameInFile, &var, DT);
  }

  if (!isValidPointer(Pointer, DT)) {
    setValidFalse();
    return std::string();
  }
  
  int size;
  setPointer(Pointer);

  std::string expression = std::string();
  std::string subExp1 = std::string();
  std::string subExp2 = std::string();
  
  size = getSizeToValue(Pointer, DT);
  size = getSizeInBytes(size);
  subExp1 = std::to_string(size) + " * ";
  subExp2 = " * " +  std::to_string(size) + ";\n";
  
  expression = getAccessString(Expression, nameF.nameInFile, &var, DT);
  
  if (var == -1) {
    long long int num = -1;
    if (TryConvertToInteger(expression, &num))
        return getValidBounds(std::to_string((num / size)), &var);

    expression += " / " + std::to_string(size) + ";\n";
    insertCommand(&var, expression);
    expression = (NAME + "[" + std::to_string(var) + "]");
    return getValidBounds(expression, &var);
  }
  expression = NAME + "[" + std::to_string(var) + "] / ";
  expression += std::to_string(size) + ";\n";
  
  var = -1;
  insertCommand(&var, expression);
  expression = (NAME + "[" + std::to_string(var) + "]");
  return getValidBounds(expression, &var);
}

std::string RecoverCode::getDataPragma (
                           std::map<std::string, std::string> & vctLower,
                           std::map<std::string, std::string> & vctUpper,
                           std::map<std::string, char> & vctPtMA) {
  std::string result = std::string();
  std::vector<std::string> loads;
  std::vector<std::string> stores;
  std::vector<std::string> ldnsts; 
  for (auto I = vctPtMA.begin(), IE = vctPtMA.end(); I != IE; I++) {
    if (I->second == 2)
      stores.push_back(I->first);
    if (I->second == 1)
      loads.push_back(I->first);
    if (I->second == 3)
      ldnsts.push_back(I->first); 
  }
  // Create data copies - Host to Devide
  if (OMPF == OMP_GPU)
    result += "#pragma omp target device (GPU_DEVICE)\n";
  if ((OMPF == OMP_GPU) || (OMPF == OMP_CPU)) {
    result += "#pragma omp target data ";
    if (loads.size() != 0)
      result += "map(to: ";
  } else {
     result += "#pragma acc data ";
    if (loads.size() != 0)
      result += "pcopyin(";
  }
  for (unsigned int i = 0, ie = loads.size(); i != ie; i++) {
    result += loads[i] + "[" + vctLower[loads[i]];
    result += ":" + vctUpper[loads[i]] + "]";
    if (i != (ie-1))
      result += ",";
  }
  if (loads.size() != 0)
    result += ") ";
  // Create data Copies - Device to Host
  if ((OMPF == OMP_CPU) || (OMPF == OMP_GPU)) {
    if (stores.size() != 0)
      result += "map(from: ";
  }
  else {
    if (stores.size() != 0)
      result += "pcopyout(";
  }
  for (unsigned int i = 0, ie = stores.size(); i != ie; i++) {
    result += stores[i] + "[" + vctLower[stores[i]];
    result += ":" + vctUpper[stores[i]] + "]";
    if (i != (ie-1))
      result += ",";
  }
  if (stores.size() != 0)
    result += ")";
  if ((OMPF == OMP_CPU) || (OMPF == OMP_GPU)) {
    if (ldnsts.size() != 0)
      result += "map(tofrom: ";
  }
  else {
    if (ldnsts.size() != 0)
      result += "pcopy(";
  }
  for (unsigned int i = 0, ie = ldnsts.size(); i != ie; i++) {
    result += ldnsts[i] + "[" + vctLower[ldnsts[i]];
    result += ":" + vctUpper[ldnsts[i]] + "]";
    if (i != (ie-1))
      result += ",";
  }
  if (ldnsts.size() != 0)
    result += ")";
  result += "\n";
  if (OMPF == ACC)
    result += "#pragma acc kernels\n";
  else if (OMPF == OMP_CPU)
    result += "#pragma omp target\n";
  return result;
}

std::string RecoverCode::getDataPragmaRegion (
                           std::map<std::string, std::string> & vctLower,
                           std::map<std::string, std::string> & vctUpper,
                           std::map<std::string, char> & vctPtMA) {
  std::string result = std::string();
  std::vector<std::string> loads;
  std::vector<std::string> stores;
  std::vector<std::string> ldnsts; 
  for (auto I = vctPtMA.begin(), IE = vctPtMA.end(); I != IE; I++) {
    if (I->second == 2)
      stores.push_back(I->first);
    if (I->second == 1) {
      loads.push_back(I->first);
    }
    if (I->second == 3)
      ldnsts.push_back(I->first); 
  }
  // Create data copies - Host to Devide
  if (OMPF == OMP_GPU)
    result += "#pragma omp target device (GPU_DEVICE)\n";
  if ((OMPF == OMP_CPU) || (OMPF == OMP_GPU)) {
    result += "#pragma omp target data ";
    if (loads.size() != 0)
      result += "map(to: ";
  } else {
     result += "#pragma acc data ";
    if (loads.size() != 0)
      result += "pcopyin(";
  }
  for (unsigned int i = 0, ie = loads.size(); i != ie; i++) {
    result += loads[i] + "[" + vctLower[loads[i]];
    result += ":" + vctUpper[loads[i]] + "]";
    if (i != (ie-1))
      result += ",";
  }
  if (loads.size() != 0)
    result += ") ";
  // Create data Copies - Device to Host
  if ((OMPF == OMP_CPU) || (OMPF == OMP_GPU)) {
    if (stores.size() != 0)
      result += "map(from: ";
  }
  else {
    if (stores.size() != 0)
      result += "pcopyout(";
  }
  for (unsigned int i = 0, ie = stores.size(); i != ie; i++) {
    result += stores[i] + "[" + vctLower[stores[i]];
    result += ":" + vctUpper[stores[i]] + "]";
    if (i != (ie-1))
      result += ",";
  }
  if (stores.size() != 0)
    result += ")";
  if ((OMPF == OMP_CPU) || (OMPF == OMP_GPU)) {
    if (ldnsts.size() != 0)
      result += "map(tofrom: ";
  }
  else {
    if (ldnsts.size() != 0)
      result += "pcopy(";
  }
  for (unsigned int i = 0, ie = ldnsts.size(); i != ie; i++) {
    result += ldnsts[i] + "[" + vctLower[ldnsts[i]];
    result += ":" + vctUpper[ldnsts[i]] + "]";
    if (i != (ie-1))
      result += ",";
  }
  if (ldnsts.size() != 0)
    result += ")";
  result += "\n";
  return result;
}

void RecoverCode::generateCorrectUB (std::string lLimit, std::string uLimit,
                                 std::string & olLimit, std::string & oSize) {
  long long int num1 = 0, num2 = 0, result = 0;
  olLimit = lLimit;
  if (TryConvertToInteger(lLimit, &num1)
      && TryConvertToInteger(uLimit, &num2)) {
    result = num2 - num1;
    if (result > 0)
      oSize = std::to_string(result);
    else {
      olLimit = std::to_string((num1 + result));
      oSize = std::to_string((-1 * result));
    }
    return;
  }

  if (lLimit == "0") {
    oSize = uLimit; 
    return;
  }

  // Provide the correct size to OMP / ACC pragmas.
  std::string expression = uLimit + " - " + lLimit + ";\n"; 
  int index = -1;                                                               
  insertCommand(&index, expression);
  std::string size = (NAME + "[" + std::to_string(index) + "]");

  // Check if the size is non-negative.
  std::string expressionTmp = "(" + size + " > 0);\n";
  int index2 = -1;
  insertCommand(&index2, expressionTmp);
 
  // Case the size is negative, correct the bounds..
  std::string newLB = lLimit + " + " + size + ";\n";
  int index3 = -1;
  insertCommand(&index3, newLB);

  std::string newSIZE = "-1 * " + size + ";\n";
  int index4 = -1;
  insertCommand(&index4, newSIZE);
 
  // Instructions to define how size will be use as Base Pointer.
  expressionTmp = (NAME + "[" + std::to_string(index2) + "] ? ");
  expressionTmp +=  lLimit + " : ";
  expressionTmp += (NAME + "[" + std::to_string(index3) + "]"); 
  expressionTmp += ";\n";
  int index5 = -1;     
  insertCommand(&index5, expressionTmp);
  olLimit = (NAME + "[" + std::to_string(index5) + "]");
  
  // Instructions to define how is the correct size.
  expressionTmp = (NAME + "[" + std::to_string(index2) + "] ? ");
  expressionTmp +=  size + " : ";
  expressionTmp += (NAME + "[" + std::to_string(index4) + "]"); 
  expressionTmp += ";\n";
  int index6 = -1;     
  insertCommand(&index6, expressionTmp);
  oSize = (NAME + "[" + std::to_string(index6) + "]");
}

bool RecoverCode::pointerDclInsideRegion(Region *R, Value *V) {
  if (isa<GlobalValue>(V) || isa<Argument>(V))
    return false;
  
  if (!isa<Instruction>(V))
    return false;

  Instruction *Inst = cast<Instruction>(V);
  for (auto BB = R->block_begin(), BE = R->block_end(); BB != BE; BB++)
    for (auto I = BB->begin(), IE = BB->end(); I != IE; I++) {
      if (Inst == I)
        return true;
    }
  return false;
}

bool RecoverCode::pointerDclInsideLoop(Loop *L, Value *V) {
  if (isa<GlobalValue>(V) || isa<Argument>(V))
    return false;
  
  if (!isa<Instruction>(V))
    return false;

  Instruction *Inst = cast<Instruction>(V);
  for (auto BB = L->block_begin(), BE = L->block_end(); BB != BE; BB++)
    for (auto I = (*BB)->begin(), IE = (*BB)->end(); I != IE; I++) {
      if (Inst == I)
        return true;
    }
  return false;
}

bool RecoverCode::needPointerAddrToRestrict(Value *V) {
  if (!isa<AllocaInst>(V))
    return false;
  // After mem2reg, we will have just local variables (as AllocaInst)
  // to provide correct pointers to restrictifier... 
  AllocaInst *ALI = cast<AllocaInst>(V);
  if (!ALI->isArrayAllocation())
    return true;
  return false;
}

bool RecoverCode::isPointerMD(Value *V) {
  if (!isa<AllocaInst>(V))
    return false;
  return true;
}

std::string RecoverCode::getPointerMD (Value *V, std::string name, int *var,
                            const DataLayout* DT) {
  if (AllocaInst *AI = dyn_cast<AllocaInst>(V)) {
    AI->dump();
    AI->getArraySize()->dump();
    std::string result =  getAccessString(AI->getArraySize(),name, var, DT);
    ConstantsSimplify CS;
    long long int size = CS.getFullSizeType(AI->getType(), DT);
    size = size / getSizeToValue(AI, DT);
    if (*var != -1) {
      if (size != 1) {
        result = "(" + NAME + "[" + std::to_string(*var) + "]";
        result += " / " + std::to_string(size) + ")";
      }
      else {
        result = NAME + "[" + std::to_string(*var) + "]";
      }
    }
    else {
      long long int num = 0;
      if (!TryConvertToInteger(result, &num)) {
         errs() << "RESULT = " << result << "\n";
        setValidFalse();
        return std::string();
      }
      if (num == 1)
        result = std::to_string((size));
      else
        result = std::to_string((num + size));
    }
    return result;
  }
  return std::string();
}

bool RecoverCode::analyzeLoop (Loop* L, int Line, int LastLine,
                                        PtrRangeAnalysis *ptrRA, 
                                        RegionInfoPass *rp, AliasAnalysis *aa,
                                        ScalarEvolution *se, LoopInfo *li,
                                        DominatorTree *dt, std::string & test) {
  
  // Initilize The Analisys with Default Values.
  initializeNewVars(); 

  Module *M = L->getLoopPredecessor()->getParent()->getParent();
  const DataLayout DT = DataLayout(M);
  std::map<Value*, std::pair<Value*, Value*> > pointerBounds;
  std::string expression = std::string();
  std::string expressionEnd = std::string();

  Restrictifier Rst = Restrictifier();
  Region *r = regionofBasicBlock((L->getLoopPreheader()), rp);

  if (!ptrRA->RegionsRangeData[r].HasFullSideEffectInfo)
    r = regionofBasicBlock((L->getHeader()), rp);
 
  if (!ptrRA->RegionsRangeData[r].HasFullSideEffectInfo)
    return false;
    
  Instruction *insertPt = r->getEntry()->getTerminator();
  SCEVRangeBuilder rangeBuilder(se, DT, aa, li, dt, r, insertPt);

  // Generate and store both bounds for each base pointer in the region.
  for (auto& pair : ptrRA->RegionsRangeData[r].BasePtrsData) {
    if (pointerDclInsideLoop(L,pair.first))
      continue;
    // Adds "sizeof(element)" to the upper bound of a pointer, so it gives us
    // the address of the first byte after the memory region.
    Value *low = rangeBuilder.getULowerBound(pair.second.AccessFunctions);
    Value *up = rangeBuilder.getUUpperBound(pair.second.AccessFunctions);
    up = rangeBuilder.stretchPtrUpperBound(pair.first, up);
    pointerBounds.insert(std::make_pair(pair.first, std::make_pair(low, up)));
    }

  std::map<std::string, std::string> vctLower;
  std::map<std::string, std::string> vctUpper;
  std::map<std::string, char> vctPtMA;
  std::map<std::string, Value*> vctPtr;
  std::map<std::string, bool> needR;

  for (auto It = pointerBounds.begin(), EIt = pointerBounds.end(); It != EIt;
       ++It) {
    
    RecoverNames::VarNames nameF = rn->getNameofValue(It->first);
    std::string lLimit = getAccessExpression(It->first, It->second.first,
        &DT, false);
    std::string uLimit = getAccessExpression(It->first, It->second.second,
        &DT, true);
   
    std::string olLimit = std::string();
    std::string oSize = std::string();
    generateCorrectUB(lLimit, uLimit, olLimit, oSize);
    vctLower[nameF.nameInFile] = olLimit;
    vctUpper[nameF.nameInFile] = oSize;
    vctPtMA[nameF.nameInFile] = ptrRA->getPointerAcessType(L, It->first);
    vctPtr[nameF.nameInFile] = It->first;
    needR[nameF.nameInFile] = needPointerAddrToRestrict(It->first);
    if (!isValid()) {
      errs() << "[TRANSFER-PRAGMA-INSERTION] WARNING: unable to generate C " <<
        " code for bounds of pointer: " << (nameF.nameInFile.empty() ?
        "<unable to recover pointer name>" : nameF.nameInFile) << "\n";
      return isValid();
    }

  }
  
  expression += getDataPragma(vctLower, vctUpper, vctPtMA);

  if (isValid()) {
    std::string result = std::string(); 
    if (getIndex() > 0) {
      result += "long long int " + NAME + "[";
      result += std::to_string(getNewIndex()) + "];\n";
      result += getUniqueString();
    }
    result += expression;

    if (OMPF == OMP_GPU)
      Rst.setTrueOMP();

    Rst.setName("RST_"+NAME);
    Rst.getBounds(vctLower, vctUpper, vctPtr, needR);
    result = Rst.generateTests(result);

    restric = Rst.isValid();
    // Use to insert test on parallel pragmas
    //if (Rst.isValid())
    //  test = "if(!RST_" + NAME + ")"; 
    Comments[Line] = result;
  }
  return isValid();
}

bool RecoverCode::analyzeRegion (Region *r, int Line, int LastLine,
                                        PtrRangeAnalysis *ptrRA, 
                                        RegionInfoPass *rp, AliasAnalysis *aa,
                                        ScalarEvolution *se, LoopInfo *li,
                                        DominatorTree *dt, std::string & test) {

  // Initilize The Analisys with Default Values.
  initializeNewVars(); 
  Module *M = r->block_begin()->getParent()->getParent();
  const DataLayout DT = DataLayout(M);
  std::map<Value*, std::pair<Value*, Value*> > pointerBounds;
  std::string expression = std::string();
  std::string expressionEnd = std::string();

  Restrictifier Rst = Restrictifier();

  if (ptrRA->RegionsRangeData[r].HasFullSideEffectInfo == false)
    return false;

  // If the region has not an Entering Block, it is not a hammoc region and 
  // the region is invalid.
  Instruction *insertPt = nullptr;
  
  if (r->isTopLevelRegion()) {
    BasicBlock *BB = *(r->block_begin());
    time_t t = time(0);
    std::string name = "AI_BLOCK" + std::to_string(t);
    BasicBlock *newBB = BB->splitBasicBlock(BB->begin(), name);
    insertPt = BB->getTerminator();
  }
  else if (r->getEnteringBlock())
    insertPt = r->getEnteringBlock()->getTerminator(); 

  if (!insertPt)
    return false;

  SCEVRangeBuilder rangeBuilder(se, DT, aa, li, dt, r, insertPt);
  // Generate and store both bounds for each base pointer in the region.
  for (auto& pair : ptrRA->RegionsRangeData[r].BasePtrsData) {
    if (pointerDclInsideRegion(r,pair.first)) {
      continue;
    }
    // Adds "sizeof(element)" to the upper bound of a pointer, so it gives us
    // the address of the first byte after the memory region.
    Value *low = rangeBuilder.getULowerBound(pair.second.AccessFunctions);
    Value *up = rangeBuilder.getUUpperBound(pair.second.AccessFunctions);
    up = rangeBuilder.stretchPtrUpperBound(pair.first, up);
    pointerBounds.insert(std::make_pair(pair.first, std::make_pair(low, up)));
  }

  std::map<std::string, std::string> vctLower;
  std::map<std::string, std::string> vctUpper;
  std::map<std::string, char> vctPtMA;
  std::map<std::string, Value*> vctPtr;
  std::map<std::string, bool> needR;

  for (auto It = pointerBounds.begin(), EIt = pointerBounds.end(); It != EIt;
       ++It) {
     
    RecoverNames::VarNames nameF = rn->getNameofValue(It->first);
    std::string lLimit = getAccessExpression(It->first, It->second.first,
        &DT, false);
    std::string uLimit = getAccessExpression(It->first, It->second.second,
        &DT, true);
   std::string olLimit = std::string();
   std::string oSize = std::string();
   generateCorrectUB(lLimit, uLimit, olLimit, oSize);
    vctLower[nameF.nameInFile] = olLimit;
    vctUpper[nameF.nameInFile] = oSize;
    vctPtMA[nameF.nameInFile] = ptrRA->getPointerAcessType(r, It->first);
    vctPtr[nameF.nameInFile] = It->first;
    needR[nameF.nameInFile] = needPointerAddrToRestrict(It->first);
    //errs() << nameF.nameInFile << "\n" << lLimit << "\n" << uLimit << "\n\n" ;
    if (!isValid()) {
      errs() << "[TRANSFER-PRAGMA-INSERTION] WARNING: unable to generate C " <<
        " code for bounds of pointer: " << (nameF.nameInFile.empty() ?
        "<unable to recover pointer name>" : nameF.nameInFile) << "\n";
      errs() << Line << "\n";
      return isValid();
    }

  }
  
  expression += getDataPragmaRegion(vctLower, vctUpper, vctPtMA);
  if (isValid()) {
    std::string result = std::string(); 
    if (getIndex() > 0) {
      result += "long long int " + NAME + "[";
      result += std::to_string(getNewIndex()) + "];\n";
      result += getUniqueString();
    }
    result += expression;

    if (OMPF == OMP_GPU)
      Rst.setTrueOMP();

    Rst.setName("RST_"+NAME);
    Rst.getBounds(vctLower, vctUpper, vctPtr, needR);
    result = Rst.generateTests(result);

    restric = Rst.isValid();
    // Use to insert test on parallel pragmas
    //if (Rst.isValid())
    //  test = "if(!RST_" + NAME + ")";
    result += "{\n";
    Comments[Line] = result;
  }
  return isValid();
}
//===---------------------------- RecoverCode.cpp -------------------------===//
